%!TeX program = lualatex
%!TeX root = main.tex
% ------------------------- Slide code với minted, không nền -------------------------

% Bài 1: Concert Tickets
\begin{frame}[fragile]{Bài 1: Concert Tickets}
\textbf{Mục tiêu:} Tìm nút có khoá lớn nhất $\le x$.

\textbf{Ý tưởng:}
\begin{itemize}
    \item Nếu $u\to key \le x$: chọn $u$ và tiếp tục sang cây con phải.
    \item Nếu $u\to key > x$: tìm ở cây con trái.
\end{itemize}

\begin{minted}[fontsize=\small, linenos, breaklines]{c++}
Node* find_predecessor(Node* u, int x) {
    Node* ans = nullptr;
    while (u) {
        if (u->key <= x) ans = u, u = u->right;
        else u = u->left;
    }
    return ans;
}
\end{minted}

\end{frame}

% Bài 1: Giải pháp đầy đủ
\begin{frame}[fragile]{Bài 1: Giải pháp đầy đủ}
\begin{minted}[fontsize=\small, linenos, breaklines]{c++}
vector<int> getTicketPrices(vector<int>& h, vector<int>& t) {
    Node* root = nullptr;
    for (int price : h) insertNode(root, price);
    vector<int> ans;
    for (int x : t) {
        Node* it = find_predecessor(root, x);
        if (!it) ans.push_back(-1);
        else {
            ans.push_back(it->key);
            eraseNode(root, it->key);
        }
    }
    return ans;
}
\end{minted}
\end{frame}

% Bài 2: Đếm số nghịch thế
\begin{frame}[fragile]{Bài 2: Đếm số nghịch thế}
\textbf{Mục tiêu:} Đếm số nút có khoá $\le x$.

\textbf{Ý tưởng:}
\begin{itemize}
    \item Nếu $u\to key \le x$: cộng size của cây con trái + 1, tiếp tục sang cây con phải.
    \item Nếu $u\to key > x$: tìm ở cây con trái.
\end{itemize}

\begin{minted}[fontsize=\small, linenos, breaklines]{c++}
int order_of_key(Node* u, int x) {
    if (!u) return 0;
    if (u->key <= x) return get_size(u->left) + 1 + order_of_key(u->right, x);
    return order_of_key(u->left, x);
}

long long countInversions(vector<int>& a) {
    Node* root = nullptr;
    long long ans = 0;
    for (int i = 0; i < (int)a.size(); i++) {
        int leq = order_of_key(root, a[i]);
        ans += i - leq;
        insertNode(root, a[i]);
    }
    return ans;
}
\end{minted}

\end{frame}

% Bài 3: Sliding Window Median
\begin{frame}[fragile]{Bài 3: Sliding Window Median}
\textbf{Ý tưởng:}
\begin{itemize}
    \item Sắp xếp nút trong cây tăng dần.
    \item Gọi $leftSize$ = kích thước cây con trái.
    \item Nếu $k \le leftSize$: tìm nút thứ $k$ bên cây con trái.
    \item Nếu $k = leftSize + 1$: $u$ chính là nút cần tìm.
    \item Nếu $k > leftSize + 1$: tìm nút thứ $k - leftSize - 1$ bên cây con phải.
\end{itemize}

\begin{minted}[fontsize=\small, linenos, breaklines]{c++}
Node* find_by_order(Node* u, int k) {
    if (!u) return nullptr;
    int leftSize = get_size(u->left);
    if (k == leftSize + 1) return u;
    if (k <= leftSize) return find_by_order(u->left, k);
    return find_by_order(u->right, k - leftSize - 1);
}
\end{minted}

\end{frame}

% Bài 3: Giải pháp Sliding Window
\begin{frame}[fragile]{Bài 3: Giải pháp Sliding Window}
\begin{minted}[fontsize=\small, linenos, breaklines]{c++}
vector<int> slidingMedian(vector<int>& a, int k) {
    vector<int> ans;
    Node* root = nullptr;
    for (int i = 0; i < a.size(); i++) {
        insertNode(root, a[i]);
        if (i >= k) eraseNode(root, a[i - k]);
        if (i >= k - 1) {
            int mid = (k + 1) / 2;
            ans.push_back(find_by_order(root, mid)->key);
        }
    }
    return ans;
}
\end{minted}

\end{frame}
